/**
 * Partner API
 * ## Version 5.4.0-SNAPSHOT  ## Information * This service provides an API to manage partners and their related subdomains   ## Contact <b>Authors</b>   <p>     <a href=\"mailto:sdd@vaudoise.ch\">SDD</a>     <a href=\"mailto:jue@vaudoise.ch\">JUE</a>     <a href=\"mailto:gme@vaudoise.ch\">GME</a>     <a href=\"mailto:sdt@vaudoise.ch\">SDT</a>     <a href=\"mailto:hua@vaudoise.ch\">HUA</a>     <a href=\"mailto:emp@vaudoise.ch\">EMP</a>     <a href=\"mailto:rla@vaudoise.ch\">RLA</a> </p>   ___ 
 *
 * OpenAPI spec version: v5
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { BankingInformationDto } from '../model/bankingInformationDto';
import { ErrorResponse } from '../model/errorResponse';
import { Log } from '../model/log';
import { MedicalRestrictionDto } from '../model/medicalRestrictionDto';
import { Partner } from '../model/partner';
import { PartnerAddress } from '../model/partnerAddress';
import { ValidationResponse } from '../model/validationResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class PartnersService {

    protected basePath = 'https://msvc-partenaire-dev.vaudoise.ch:35361/v5';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Retrieve the bank accounts for a given policy holder id
     * 
     * @param policyHolderId policyHolderId
     * @param acceptLanguage Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBankAccountsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'body', reportProgress?: boolean): Observable<Array<BankingInformationDto>>;
    public getBankAccountsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BankingInformationDto>>>;
    public getBankAccountsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BankingInformationDto>>>;
    public getBankAccountsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (policyHolderId === null || policyHolderId === undefined) {
            throw new Error('Required parameter policyHolderId was null or undefined when calling getBankAccountsUsingGET.');
        }


        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BankingInformationDto>>(`${this.basePath}/partners/${encodeURIComponent(String(policyHolderId))}/bank-accounts`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the comment for a given policy holder id
     * 
     * @param policyHolderId policyHolderId
     * @param acceptLanguage Language
     * @param effectiveDate Effective date of the comment, in format &#x3D; YYYY-MM-DD, example &#x3D; 2018-03-16
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCommentUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', effectiveDate?: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getCommentUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', effectiveDate?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getCommentUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', effectiveDate?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getCommentUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', effectiveDate?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (policyHolderId === null || policyHolderId === undefined) {
            throw new Error('Required parameter policyHolderId was null or undefined when calling getCommentUsingGET.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (effectiveDate !== undefined && effectiveDate !== null) {
            queryParameters = queryParameters.set('effectiveDate', <any>effectiveDate);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/partners/${encodeURIComponent(String(policyHolderId))}/comment`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the comments for a given policy holder id
     * 
     * @param policyHolderId policyHolderId
     * @param acceptLanguage Language
     * @param effectiveDate Effective date of the comments, in format &#x3D; YYYY-MM-DD
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCommentsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', effectiveDate?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public getCommentsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', effectiveDate?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public getCommentsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', effectiveDate?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public getCommentsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', effectiveDate?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (policyHolderId === null || policyHolderId === undefined) {
            throw new Error('Required parameter policyHolderId was null or undefined when calling getCommentsUsingGET.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (effectiveDate !== undefined && effectiveDate !== null) {
            queryParameters = queryParameters.set('effectiveDate', <any>effectiveDate);
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<string>>(`${this.basePath}/partners/${encodeURIComponent(String(policyHolderId))}/comments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the list of logs for a given partner
     * 
     * @param policyHolderId policyHolderId
     * @param acceptLanguage Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLogsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'body', reportProgress?: boolean): Observable<Array<Log>>;
    public getLogsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Log>>>;
    public getLogsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Log>>>;
    public getLogsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (policyHolderId === null || policyHolderId === undefined) {
            throw new Error('Required parameter policyHolderId was null or undefined when calling getLogsUsingGET.');
        }


        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Log>>(`${this.basePath}/partners/${encodeURIComponent(String(policyHolderId))}/logs`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the medical restrictions for a given policy holder id
     * 
     * @param policyHolderId policyHolderId
     * @param acceptLanguage Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMedicalRestrictionsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'body', reportProgress?: boolean): Observable<Array<MedicalRestrictionDto>>;
    public getMedicalRestrictionsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MedicalRestrictionDto>>>;
    public getMedicalRestrictionsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MedicalRestrictionDto>>>;
    public getMedicalRestrictionsUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (policyHolderId === null || policyHolderId === undefined) {
            throw new Error('Required parameter policyHolderId was null or undefined when calling getMedicalRestrictionsUsingGET.');
        }


        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<MedicalRestrictionDto>>(`${this.basePath}/partners/${encodeURIComponent(String(policyHolderId))}/medical-restrictions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the list of addresses for a given partner
     * 
     * @param policyHolderId policyHolderId
     * @param acceptLanguage Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPartnerAddressesUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'body', reportProgress?: boolean): Observable<Array<PartnerAddress>>;
    public getPartnerAddressesUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PartnerAddress>>>;
    public getPartnerAddressesUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PartnerAddress>>>;
    public getPartnerAddressesUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (policyHolderId === null || policyHolderId === undefined) {
            throw new Error('Required parameter policyHolderId was null or undefined when calling getPartnerAddressesUsingGET.');
        }


        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PartnerAddress>>(`${this.basePath}/partners/${encodeURIComponent(String(policyHolderId))}/addresses`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve a partner for a given policy holder id
     * 
     * @param policyHolderId policyHolderId
     * @param acceptLanguage Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPartnerUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'body', reportProgress?: boolean): Observable<Partner>;
    public getPartnerUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Partner>>;
    public getPartnerUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Partner>>;
    public getPartnerUsingGET(policyHolderId: number, acceptLanguage?: 'FR' | 'DE' | 'IT', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (policyHolderId === null || policyHolderId === undefined) {
            throw new Error('Required parameter policyHolderId was null or undefined when calling getPartnerUsingGET.');
        }


        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Partner>(`${this.basePath}/partners/${encodeURIComponent(String(policyHolderId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the list of partners
     * &lt;p style&#x3D;\&quot;color:red\&quot;&gt;Searching by multiple Policy holder Ids can have a performance impact.&lt;/p&gt;
     * @param page Page number. Starting from 0
     * @param size Page size. By default 20
     * @param acceptLanguage Language
     * @param birthDate Birth date in format YYYY-MM-DD - Only for people. Beware that search by birth date only can result in bad response time. Example: 1980-02-20
     * @param city Swiss city (official city name in 20 characters, examples : &#39;Bern&#39;, &#39;Zürich&#39;, &#39;Genève&#39;, &#39;Villars-sur-Ollon&#39;, &#39;Aeugst am Albis&#39;) Tolerates fuzzy search like &#39;Zurich&#39;, &#39;Villars&#39;, &#39;Geneve&#39;, &#39;AEUGST&#39;. - Searches on all addresses, not just the principal address
     * @param email E-mail
     * @param firstName First name of the partner. Use &amp;quot;\\*&amp;quot; as wildcard. Example: Johann,\\*o\\*ann
     * @param iban Iban
     * @param isnPers IsnPers
     * @param name Last name, Company name or couple name. Use &amp;quot;\\*&amp;quot; as wildcard. Example: Pache,Pa\\*che
     * @param partnerTypes List of Partner types in camel case. Example: person
     * @param petName Name of the pet owned by the partner. Use &amp;quot;\\*&amp;quot; as wildcard. Example: Can\\*el\\*e, , to search for a pet with name like &#39;Cannelle&#39; or &#39;Canelle&#39; or &#39;Canele&#39; or &#39;Canelle&#39;
     * @param phoneNumber phoneNumber
     * @param policyHolderId List of policy holder ids
     * @param postCode Swiss post code - Searches on all addresses, not just the principal address
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported (on separate lines). Possible sort attributes are : policyHolderId | firstName | lastName | companyName | coupleName | birthDate | address.postCode | address.city
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchPartnersUsingGET(page?: number, size?: number, acceptLanguage?: 'FR' | 'DE' | 'IT', birthDate?: string, city?: string, email?: string, firstName?: string, iban?: string, isnPers?: number, name?: string, partnerTypes?: Array<'person' | 'company' | 'couple'>, petName?: string, phoneNumber?: string, policyHolderId?: Array<number>, postCode?: string, sort?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<Partner>>;
    public searchPartnersUsingGET(page?: number, size?: number, acceptLanguage?: 'FR' | 'DE' | 'IT', birthDate?: string, city?: string, email?: string, firstName?: string, iban?: string, isnPers?: number, name?: string, partnerTypes?: Array<'person' | 'company' | 'couple'>, petName?: string, phoneNumber?: string, policyHolderId?: Array<number>, postCode?: string, sort?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Partner>>>;
    public searchPartnersUsingGET(page?: number, size?: number, acceptLanguage?: 'FR' | 'DE' | 'IT', birthDate?: string, city?: string, email?: string, firstName?: string, iban?: string, isnPers?: number, name?: string, partnerTypes?: Array<'person' | 'company' | 'couple'>, petName?: string, phoneNumber?: string, policyHolderId?: Array<number>, postCode?: string, sort?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Partner>>>;
    public searchPartnersUsingGET(page?: number, size?: number, acceptLanguage?: 'FR' | 'DE' | 'IT', birthDate?: string, city?: string, email?: string, firstName?: string, iban?: string, isnPers?: number, name?: string, partnerTypes?: Array<'person' | 'company' | 'couple'>, petName?: string, phoneNumber?: string, policyHolderId?: Array<number>, postCode?: string, sort?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('$page', <any>page);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('$size', <any>size);
        }
        if (birthDate !== undefined && birthDate !== null) {
            queryParameters = queryParameters.set('birthDate', <any>birthDate);
        }
        if (city !== undefined && city !== null) {
            queryParameters = queryParameters.set('city', <any>city);
        }
        if (email !== undefined && email !== null) {
            queryParameters = queryParameters.set('email', <any>email);
        }
        if (firstName !== undefined && firstName !== null) {
            queryParameters = queryParameters.set('firstName', <any>firstName);
        }
        if (iban !== undefined && iban !== null) {
            queryParameters = queryParameters.set('iban', <any>iban);
        }
        if (isnPers !== undefined && isnPers !== null) {
            queryParameters = queryParameters.set('isnPers', <any>isnPers);
        }
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (partnerTypes) {
            partnerTypes.forEach((element) => {
                queryParameters = queryParameters.append('partnerTypes', <any>element);
            })
        }
        if (petName !== undefined && petName !== null) {
            queryParameters = queryParameters.set('petName', <any>petName);
        }
        if (phoneNumber !== undefined && phoneNumber !== null) {
            queryParameters = queryParameters.set('phoneNumber', <any>phoneNumber);
        }
        if (policyHolderId) {
            policyHolderId.forEach((element) => {
                queryParameters = queryParameters.append('policyHolderId', <any>element);
            })
        }
        if (postCode !== undefined && postCode !== null) {
            queryParameters = queryParameters.set('postCode', <any>postCode);
        }
        if (sort) {
            sort.forEach((element) => {
                queryParameters = queryParameters.append('sort', <any>element);
            })
        }

        let headers = this.defaultHeaders;
        if (acceptLanguage !== undefined && acceptLanguage !== null) {
            headers = headers.set('Accept-Language', String(acceptLanguage));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<Partner>>(`${this.basePath}/partners`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
